"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ActorStateManager_1 = __importDefault(require("./ActorStateManager"));
var StateProvider_1 = __importDefault(require("./StateProvider"));
/**
 * Represents the base class for actors.
 * The base type for actors, that provides the common functionality for actors.
 * The state is preserved across actor garbage collections and fail-overs.
 *
 * Example
 *
 * export default interface IDemoCounterActor extends IActor {
 *   increment(amount: number): void;
 * }
 *
 * export default class DemoActorImpl extends AbstractActor implements IDemoActor {
 *   increment(amount: number): void {
 *     throw new Error("Method not implemented.");
 *   }
 * }
 */
var AbstractActor = /** @class */ (function () {
    /**
     * Instantiates a new Actor
     *
     * @param runtimeContext context for the runtime
     * @param id actor identifier
     */
    function AbstractActor(daprClient, id) {
        this.daprClient = daprClient;
        this.id = id;
        this.stateManager = new ActorStateManager_1.default(this);
        this.daprStateProvider = new StateProvider_1.default(this.daprClient);
        // Interesting one: get the Class Type of the child
        this.actorType = this.constructor.name;
    }
    /**
     * Registers a reminder for this actor
     *
     * Reminders are a mechanism to trigger persistent callbacks on an actor at specified times.
     * Their functionality is similar to timers. But unlike timers, reminders are triggered under
     * all circumstances until the actor explicitly unregisters them or the actor is explicitly
     * deleted. Specifically, reminders are triggered across actor deactivations and failovers
     * because the Actors runtime persists information about the actor's reminders using actor
     * state provider. Also existing reminders can be updated by calling this registration method
     * again using the same reminderName.
     *
     * @todo:
     * https://github.com/dapr/java-sdk/blob/master/sdk-actors/src/main/java/io/dapr/actors/runtime/AbstractActor.java
     * https://github.com/dapr/python-sdk/blob/46c5664d2e75c20122120dab3be882c4d059a987/dapr/actor/runtime/actor.py#L93
     *
     * @param reminderName name of the reminder
     * @param state the state to be send along with the reminder trigger
     * @param dueTime due time for the first trigger
     * @param period frequency for the triggers
     * @param <Type> Type of the state object
     * @return Async void response
     */
    // async registerReminder<Type>(reminderName: string, state: Buffer, dueTime: string, period: string) {
    //   const actorType = this.runtimeCtx.actorTypeInfo.name;
    //   await this.runtimeCtx.daprClient.actor.reminderCreate(actorType, this.id.id, reminderName, {
    //     period,
    //     dueTime,
    //     data: state
    //   });
    // }
    // async unregisterReminder(reminderName: string) {
    //   const actorType = this.runtimeCtx.actorTypeInfo.name;
    //   await this.runtimeCtx.daprClient.actor.reminderDelete(actorType, this.id.id, reminderName);
    // }
    AbstractActor.prototype.registerTimer = function (timerName, callback, dueTime, period, state) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // // Make sure to activate the actor
                        // const actor = await ActorRuntime.getInstance(this.client).getActorManager(this.actorType).getActiveActor(this.id);
                        // Register the timer in the sidecar
                        console.log("actorType: " + this.actorType + ", actorId: " + this.id.getId() + ", timerName: " + timerName + ", callback: " + callback + ", dueTime: " + dueTime.toString() + ", period: " + period.toString());
                        return [4 /*yield*/, this.daprClient.actor.timerCreate(this.actorType, this.id.getId(), timerName, {
                                period: period,
                                dueTime: dueTime,
                                data: state,
                                callback: callback
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Clears all state cache, calls the overridden onActivate and then saves the states
     * This method gets called when the actor is activated
     * Note: we require this to save the state so that we know the actor got activated!
     */
    AbstractActor.prototype.onActivateInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resetStateInternal()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.onActivate()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.saveStateInternal()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Clears all state cache and calls the overridden method onDeactivate
     * This callback is called when an actor is deactivated
     */
    AbstractActor.prototype.onDeactivateInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.resetStateInternal()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.onDeactivate()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.saveStateInternal()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Calls the onActorMethodPre hook on the actor implementation
     * This gets called just before executing a method
     */
    AbstractActor.prototype.onActorMethodPreInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.onActorMethodPre()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Calls the onActorMethodPost hook on the actor implementation
     * This gets called just after executing a method
     * It also persists the state changes of the actor
     */
    AbstractActor.prototype.onActorMethodPostInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.onActorMethodPost()];
                    case 1:
                        _a.sent();
                        // We need to save the state of the actor
                        return [4 /*yield*/, this.saveStateInternal()];
                    case 2:
                        // We need to save the state of the actor
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This will be called when an actor method invocation failed or the actor is activated
     */
    AbstractActor.prototype.resetStateInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.stateManager.clearCache()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Saves all the state changes (ADD/UPDATE/REMOVE) that were made since the last call
     * to the actor state provider associated with teh actor
     */
    AbstractActor.prototype.saveStateInternal = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.stateManager.saveState()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * This method gets called right after an actor gets activated
     * and before a method call or reminders are dispatched on it
     */
    AbstractActor.prototype.onActivate = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * This method gets called right before an actor gets deactivated
     */
    AbstractActor.prototype.onDeactivate = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets called before executing a method
     * @returns
     */
    AbstractActor.prototype.onActorMethodPre = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets called after executing a method
     * @returns
     */
    AbstractActor.prototype.onActorMethodPost = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    AbstractActor.prototype.receiveReminder = function (data) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                console.warn(JSON.stringify({
                    error: "ACTOR_METHOD_NOT_IMPLEMENTED",
                    errorMsg: "A reminder was created for the actor with id: " + this.id.getId() + " but the method 'receiveReminder' was not implemented",
                }));
                return [2 /*return*/];
            });
        });
    };
    AbstractActor.prototype.getDaprClient = function () {
        return this.daprClient;
    };
    AbstractActor.prototype.getStateProvider = function () {
        return this.daprStateProvider;
    };
    AbstractActor.prototype.getStateManager = function () {
        return this.stateManager;
    };
    AbstractActor.prototype.getId = function () {
        return this.id;
    };
    AbstractActor.prototype.getActorType = function () {
        return this.actorType;
    };
    return AbstractActor;
}());
exports.default = AbstractActor;
