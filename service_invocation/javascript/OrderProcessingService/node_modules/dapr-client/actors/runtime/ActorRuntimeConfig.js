"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var polyfill_1 = require("@js-temporal/polyfill");
/**
 * Actor runtime configuration that configures the Actor behavior in the Dapr Runtime
 */
var ActorRuntimeConfig = /** @class */ (function () {
    /**
     *
     * @param actorIdleTimeout The timeout before deactivating an idle actor
     * @param actorScanInterval The duration which specifies how often to scan for actors
     * to deactivate idle actors. Actors that have been idle longer than actorIdleTimeout will be deactivated
     * @param drainOngoingCallTimeout The duration when in the process of draining rebalanced actors.
     * This specifies the timeout for the current active actor method to finish.
     * If there is no current actor method call, this is ignored.
     * @param drainRebalancedActors If true, Dapr will wait for drainOngoingCallTimeout
     * to allow a current actor call to complete before trying to deactivate an actor
     */
    function ActorRuntimeConfig(actorIdleTimeout, actorScanInterval, drainOngoingCallTimeout, drainRebalancedActors) {
        if (actorIdleTimeout === void 0) { actorIdleTimeout = polyfill_1.Temporal.Duration.from({ hours: 1 }); }
        if (actorScanInterval === void 0) { actorScanInterval = polyfill_1.Temporal.Duration.from({ seconds: 30 }); }
        if (drainOngoingCallTimeout === void 0) { drainOngoingCallTimeout = polyfill_1.Temporal.Duration.from({ minutes: 1 }); }
        if (drainRebalancedActors === void 0) { drainRebalancedActors = true; }
        this.actorIdleTimeout = actorIdleTimeout;
        this.actorScanInterval = actorScanInterval;
        this.drainOngoingCallTimeout = drainOngoingCallTimeout;
        this.drainRebalancedActors = drainRebalancedActors;
    }
    ActorRuntimeConfig.prototype.getActorIdleTimeout = function () {
        return this.actorIdleTimeout.total({ unit: 'second' });
    };
    ActorRuntimeConfig.prototype.getActorScanInterval = function () {
        return this.actorScanInterval.total({ unit: 'second' });
    };
    ActorRuntimeConfig.prototype.getDrainOngoingCallTimeout = function () {
        return this.drainOngoingCallTimeout.total({ unit: 'second' });
    };
    ActorRuntimeConfig.prototype.getDrainRebalancedActors = function () {
        return this.drainRebalancedActors;
    };
    ActorRuntimeConfig.prototype.toDictionary = function () {
        return {
            actorIdleTimeout: this.actorIdleTimeout.toString().replace("PT", "").toLocaleLowerCase(),
            actorScanInterval: this.actorScanInterval.toString().replace("PT", "").toLocaleLowerCase(),
            drainOngoingCallTimeout: this.drainOngoingCallTimeout.toString().replace("PT", "").toLocaleLowerCase(),
            drainRebalancedActors: this.drainRebalancedActors
        };
    };
    return ActorRuntimeConfig;
}());
exports.default = ActorRuntimeConfig;
